<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯ÙˆØ¯Ø©</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #fbbc04;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            transition: background 0.3s ease;
        }

        body.dark-mode {
            background: #202124;
        }

        .container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            max-width: 95vw;
            transition: background 0.3s ease, color 0.3s ease;
            max-height: 95vh;
            overflow-y: auto;
        }

        body.dark-mode .container {
            background: #292a2d;
        }

        h1 {
            color: #5f6368;
            margin-bottom: 15px;
            font-size: 2em;
            font-weight: 400;
            transition: color 0.3s ease;
        }

        body.dark-mode h1 {
            color: #e8eaed;
        }

        .emoji {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .score-item {
            color: #5f6368;
            font-size: 1.1em;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        body.dark-mode .score-item {
            color: #e8eaed;
        }

        .score-value {
            color: #1a73e8;
            font-weight: bold;
            font-size: 1.3em;
        }

        #gameCanvas {
            border: 2px solid #dadce0;
            border-radius: 4px;
            background: #f8f9fa;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1);
            display: block;
            margin: 0 auto 20px;
            max-width: 100%;
            touch-action: none;
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        body.dark-mode #gameCanvas {
            background: #202124;
            border-color: #5f6368;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 70px);
            gap: 8px;
            justify-content: center;
            margin: 20px auto;
            max-width: 230px;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            font-size: 1.5em;
            border: 2px solid #dadce0;
            border-radius: 50%;
            background: white;
            color: #5f6368;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:active {
            transform: scale(0.95);
            background: #f1f3f4;
        }

        .control-btn:hover {
            background: #f8f9fa;
            border-color: #1a73e8;
            color: #1a73e8;
        }

        .control-btn:nth-child(1) {
            grid-column: 2;
        }

        .control-btn:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }

        .control-btn:nth-child(3) {
            grid-column: 3;
            grid-row: 2;
        }

        .control-btn:nth-child(4) {
            grid-column: 2;
            grid-row: 2;
        }

        #startBtn, #restartBtn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 12px 32px;
            font-size: 1.1em;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
            transition: all 0.3s;
            margin: 10px auto;
            pointer-events: auto;
        }

        #startBtn:hover, #restartBtn:hover {
            background: #1765cc;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        #startBtn:active, #restartBtn:active {
            transform: translateY(1px);
        }

        .game-over {
            color: #ea4335;
            font-size: 1.8em;
            font-weight: 500;
            margin: 10px 0;
        }

        .instructions {
            margin-top: 15px;
            color: #5f6368;
            font-size: 0.9em;
            transition: color 0.3s ease;
        }

        body.dark-mode .instructions {
            color: #9aa0a6;
        }

        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        body.dark-mode .start-screen {
            background: rgba(41, 42, 45, 0.95);
        }

        .start-screen.hidden {
            display: none;
        }

        .game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.98);
            padding: 40px 50px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            display: none;
            animation: gameOverAnim 0.4s ease-out;
        }

        body.dark-mode .game-over-screen {
            background: rgba(41, 42, 45, 0.98);
        }

        .game-over-screen.show {
            display: block;
        }

        .final-score {
            color: #1a73e8;
            font-size: 1.5em;
            font-weight: bold;
            margin: 20px 0;
        }

        body.dark-mode .final-score {
            color: #8ab4f8;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5em;
            }

            .container {
                padding: 10px;
            }

            .score-board {
                margin-bottom: 10px;
                font-size: 0.9em;
            }

            #gameCanvas {
                max-width: 90vw;
                width: auto;
                height: auto;
            }

            .instructions {
                font-size: 0.85em;
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h1 style="margin: 0; flex: 1; text-align: center;">ğŸ Snake Game</h1>
            <button id="themeToggle" style="background: #5f6368; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 1.2em;">ğŸŒ™</button>
        </div>
        
        <div class="score-board">
            <div class="score-item">
                Ø§Ù„Ù†Ù‚Ø§Ø·: <span class="score-value" id="score">0</span>
            </div>
            <div class="score-item">
                Ø§Ù„Ø£Ø¹Ù„Ù‰: <span class="score-value" id="highScore">0</span>
            </div>
        </div>

        <div style="position: relative; display: inline-block;">
            <canvas id="gameCanvas" width="360" height="640"></canvas>
            <div class="start-screen" id="startScreen">
                <div class="emoji">ğŸ</div>
                <button id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
            </div>
            <div class="game-over-screen" id="gameOverScreen">
                <div class="game-over">ğŸ’€ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! ğŸ’€</div>
                <div class="final-score">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="finalScore">0</span></div>
                <button id="restartBtn">ğŸ”„ Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
            </div>
        </div>

        <div class="instructions">
            Ø§Ø³Ø­Ø¨ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ù„Ù„ØªØ­ÙƒÙ… Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ù‡Ù… ğŸ‘†
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const startBtn = document.getElementById('startBtn');
        const startScreen = document.getElementById('startScreen');

        const gridSize = 20;
        const tileCountX = 18; // 360 / 20
        const tileCountY = 32; // 640 / 20

        // Ø£Ù„ÙˆØ§Ù† Ø¬ÙˆØ¬Ù„
        const colors = {
            blue: '#4285f4',
            red: '#ea4335',
            yellow: '#fbbc04',
            green: '#34a853',
            background: '#f8f9fa',
            grid: '#e8eaed'
        };

        const darkColors = {
            blue: '#8ab4f8',
            red: '#f28b82',
            yellow: '#fdd663',
            green: '#81c995',
            background: '#202124',
            grid: '#3c4043'
        };

        let currentColors = colors;
        let isDarkMode = false;

        let snake = [];
        let food = {x: 0, y: 0};
        let dx = 0;
        let dy = 0;
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameRunning = false;
        let gameStarted = false;
        let gameSpeed = 120;
        let lastDirection = {dx: 0, dy: 0};
        let snakeColors = [];

        // Ù…ØªØºÙŠØ±Ø§Øª Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 30; // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ù…Ø³Ø§ÙØ© Ù„Ù„Ø³Ø­Ø¨

        // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
        let animationProgress = 0;
        let lastMoveTime = 0;
        let nextSegments = [];

        highScoreEl.textContent = highScore;

        // Ø§Ù„Ù…Ø¤Ø«Ø±Ø§Øª Ø§Ù„ØµÙˆØªÙŠØ©
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playEatSound() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.value = 600;
            gain.gain.value = 0.1;
            
            osc.start(audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(900, audioContext.currentTime + 0.08);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
            osc.stop(audioContext.currentTime + 0.08);
        }

        function playGameOverSound() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.value = 400;
            gain.gain.value = 0.12;
            
            osc.start(audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.25);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
            osc.stop(audioContext.currentTime + 0.25);
        }

        function getSnakeColor(index) {
            const colorArray = [currentColors.blue, currentColors.green, currentColors.yellow, currentColors.red];
            return colorArray[index % colorArray.length];
        }

        function initGame() {
            const startX = Math.floor(tileCountX / 2);
            const startY = Math.floor(tileCountY / 2);
            snake = [
                {x: startX, y: startY},
                {x: startX - 1, y: startY},
                {x: startX - 2, y: startY},
                {x: startX - 3, y: startY}
            ];
            snakeColors = snake.map((_, i) => getSnakeColor(i));
            placeFood();
        }

        function drawGame() {
            // Ø§Ù„Ø®Ù„ÙÙŠØ©
            ctx.fillStyle = currentColors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø®ÙÙŠÙØ©
            ctx.strokeStyle = currentColors.grid;
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= tileCountX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= tileCountY; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Ø±Ø³Ù… Ø§Ù„Ø¯ÙˆØ¯Ø© ÙƒØ¬Ø³Ù… Ù…ØªØµÙ„ Ù…Ø¹ Ø£Ù†ÙŠÙ…ÙŠØ´Ù† Ø³Ù„Ø³
            if (snake.length > 0) {
                const segments = [];
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
                for (let i = 0; i < snake.length; i++) {
                    let currentX = snake[i].x * gridSize + gridSize / 2;
                    let currentY = snake[i].y * gridSize + gridSize / 2;
                    
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø­Ø±ÙƒØ© Ù‚Ø§Ø¯Ù…Ø©ØŒ Ù†Ø­Ø³Ø¨ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ÙŠ
                    if (nextSegments.length > i) {
                        const nextX = nextSegments[i].x * gridSize + gridSize / 2;
                        const nextY = nextSegments[i].y * gridSize + gridSize / 2;
                        
                        // Ø§Ø³ØªØ®Ø¯Ø§Ù… easing Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø³Ù„Ø³Ø©
                        const easeProgress = easeInOutQuad(animationProgress);
                        currentX = currentX + (nextX - currentX) * easeProgress;
                        currentY = currentY + (nextY - currentY) * easeProgress;
                    }
                    
                    segments.push({x: currentX, y: currentY});
                }

                // Ø±Ø³Ù… Ø§Ù„Ø¬Ø³Ù… ÙƒÙ…Ù†Ø­Ù†Ù‰ Ø³Ù„Ø³
                const radius = gridSize / 2.3;
                
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = radius * 2;

                // Ø±Ø³Ù… Ø§Ù„Ø¬Ø³Ù… Ø¨ØªØ¯Ø±Ø¬ Ù„ÙˆÙ†ÙŠ
                if (segments.length > 1) {
                    // Ø±Ø³Ù… Ø®Ø· ÙˆØ§Ø­Ø¯ Ù…ØªØµÙ„ Ù„Ù„Ø¬Ø³Ù… ÙƒÙ„Ù‡
                    ctx.beginPath();
                    ctx.moveTo(segments[0].x, segments[0].y);
                    
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø­Ù†ÙŠØ§Øª Ø¨ÙŠØ²ÙŠØ± Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø³Ù„Ø³Ø©
                    for (let i = 1; i < segments.length; i++) {
                        if (i === segments.length - 1) {
                            ctx.lineTo(segments[i].x, segments[i].y);
                        } else {
                            // Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ù†Ø­Ù†Ù‰
                            const xc = (segments[i].x + segments[i + 1].x) / 2;
                            const yc = (segments[i].y + segments[i + 1].y) / 2;
                            ctx.quadraticCurveTo(segments[i].x, segments[i].y, xc, yc);
                        }
                    }
                    
                    // ØªØ¯Ø±Ø¬ Ù„ÙˆÙ†ÙŠ Ù„Ù„Ø¬Ø³Ù…
                    const gradient = ctx.createLinearGradient(
                        segments[0].x, segments[0].y,
                        segments[segments.length - 1].x, segments[segments.length - 1].y
                    );
                    gradient.addColorStop(0, currentColors.blue);
                    gradient.addColorStop(0.3, currentColors.green);
                    gradient.addColorStop(0.6, currentColors.yellow);
                    gradient.addColorStop(1, currentColors.red);
                    
                    ctx.strokeStyle = gradient;
                    ctx.stroke();
                }

                // Ø±Ø³Ù… Ø§Ù„Ø±Ø£Ø³ Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ø±ÙŠ Ø£ÙƒØ¨Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹
                const head = segments[0];
                const headGradient = ctx.createRadialGradient(
                    head.x, head.y, 0,
                    head.x, head.y, radius + 2
                );
                headGradient.addColorStop(0, currentColors.blue);
                headGradient.addColorStop(0.7, currentColors.blue);
                headGradient.addColorStop(1, 'rgba(66, 133, 244, 0.7)');
                
                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(head.x, head.y, radius + 2, 0, Math.PI * 2);
                ctx.fill();

                // Ø±Ø³Ù… Ø§Ù„Ø¹ÙŠÙˆÙ†
                ctx.fillStyle = 'white';
                const eyeSize = 4;
                
                // ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø¹ÙŠÙˆÙ† Ø­Ø³Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
                if (dx === 1) { // ÙŠÙ…ÙŠÙ†
                    ctx.beginPath();
                    ctx.arc(head.x + 6, head.y - 5, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x + 6, head.y + 5, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#202124';
                    ctx.beginPath();
                    ctx.arc(head.x + 7, head.y - 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x + 7, head.y + 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (dx === -1) { // ÙŠØ³Ø§Ø±
                    ctx.beginPath();
                    ctx.arc(head.x - 6, head.y - 5, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x - 6, head.y + 5, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#202124';
                    ctx.beginPath();
                    ctx.arc(head.x - 7, head.y - 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x - 7, head.y + 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (dy === -1) { // ÙÙˆÙ‚
                    ctx.beginPath();
                    ctx.arc(head.x - 5, head.y - 6, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x + 5, head.y - 6, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#202124';
                    ctx.beginPath();
                    ctx.arc(head.x - 5, head.y - 7, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x + 5, head.y - 7, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else { // ØªØ­Øª
                    ctx.beginPath();
                    ctx.arc(head.x - 5, head.y + 6, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x + 5, head.y + 6, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#202124';
                    ctx.beginPath();
                    ctx.arc(head.x - 5, head.y + 7, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(head.x + 5, head.y + 7, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Ø±Ø³Ù… Ø§Ù„Ø°ÙŠÙ„ Ø¨Ø´ÙƒÙ„ Ù…Ø¯Ø¨Ø¨
                if (segments.length > 1) {
                    const tail = segments[segments.length - 1];
                    const tailGradient = ctx.createRadialGradient(
                        tail.x, tail.y, 0,
                        tail.x, tail.y, radius * 0.7
                    );
                    tailGradient.addColorStop(0, currentColors.red);
                    tailGradient.addColorStop(1, 'rgba(234, 67, 53, 0.5)');
                    
                    ctx.fillStyle = tailGradient;
                    ctx.beginPath();
                    ctx.arc(tail.x, tail.y, radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Ø±Ø³Ù… Ø§Ù„Ø·Ø¹Ø§Ù… ÙƒØªÙØ§Ø­Ø© Ø­Ù…Ø±Ø§Ø¡ Ù…Ø¹ Ø£Ù†ÙŠÙ…ÙŠØ´Ù† Ù†Ø¨Ø¶
            const time = Date.now() / 500;
            const pulse = Math.sin(time) * 0.1 + 1;
            
            const fx = food.x * gridSize + gridSize / 2;
            const fy = food.y * gridSize + gridSize / 2;
            
            ctx.save();
            ctx.translate(fx, fy);
            ctx.scale(pulse, pulse);
            
            // Ø§Ù„ØªÙØ§Ø­Ø©
            ctx.fillStyle = currentColors.red;
            ctx.beginPath();
            ctx.arc(0, 0, gridSize/3, 0, Math.PI * 2);
            ctx.fill();

            // Ø§Ù„ÙˆØ±Ù‚Ø© Ø§Ù„Ø®Ø¶Ø±Ø§Ø¡
            ctx.fillStyle = currentColors.green;
            ctx.beginPath();
            ctx.ellipse(5, -8, 4, 6, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            // Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡ Ù„Ù„Ø¨Ø±ÙŠÙ‚
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(-3, -3, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        // Ø¯Ø§Ù„Ø© easing Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø³Ù„Ø³Ø©
        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        function moveSnake() {
            if (dx === 0 && dy === 0) return;

            const head = {x: snake[0].x + dx, y: snake[0].y + dy};

            // ÙØ­Øµ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø­Ø§Ø¦Ø·
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                gameOver();
                return;
            }

            // ÙØ­Øµ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø¬Ø³Ù…
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            // Ø­ÙØ¸ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© Ù„Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
            nextSegments = [{x: head.x, y: head.y}];
            for (let i = 0; i < snake.length - 1; i++) {
                nextSegments.push({x: snake[i].x, y: snake[i].y});
            }

            snake.unshift(head);

            // ÙØ­Øµ Ø§Ù„Ø£ÙƒÙ„
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreEl.textContent = score;
                playEatSound();
                placeFood();
                
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£Ø®ÙŠØ± Ù„Ù„Ø¯ÙˆØ¯Ø© ÙÙŠ nextSegments
                nextSegments.push({x: snake[snake.length - 1].x, y: snake[snake.length - 1].y});
                
                if (score % 50 === 0 && gameSpeed > 60) {
                    gameSpeed -= 5;
                }
            } else {
                snake.pop();
            }

            lastDirection = {dx, dy};
        }

        function placeFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY)
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
            
            food = newFood;
        }

        function gameOver() {
            gameRunning = false;
            playGameOverSound();
            finalScoreEl.textContent = score;
            gameOverScreen.classList.add('show');

            if (score > highScore) {
                highScore = score;
                highScoreEl.textContent = highScore;
                localStorage.setItem('snakeHighScore', highScore);
            }
        }

        function startGame() {
            gameStarted = true;
            startScreen.classList.add('hidden');
            initGame();
            dx = 1;
            dy = 0;
            lastDirection = {dx: 1, dy: 0};
            animationProgress = 0;
            nextSegments = [];
            lastMoveTime = performance.now();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            score = 0;
            gameSpeed = 120;
            scoreEl.textContent = score;
            gameOverScreen.classList.remove('show');
            initGame();
            dx = 1;
            dy = 0;
            lastDirection = {dx: 1, dy: 0};
            animationProgress = 0;
            nextSegments = [];
            lastMoveTime = performance.now();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function changeDirection(newDx, newDy) {
            if (!gameStarted) {
                startGame();
                return;
            }

            if ((newDx === -lastDirection.dx && newDx !== 0) || 
                (newDy === -lastDirection.dy && newDy !== 0)) {
                return;
            }
            
            dx = newDx;
            dy = newDy;
        }

        function gameLoop(currentTime = 0) {
            if (!gameRunning) return;

            // Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù†Ù‚Ø¶ÙŠ
            const deltaTime = currentTime - lastMoveTime;

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù† Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ…Ø±
            if (deltaTime >= gameSpeed) {
                moveSnake();
                animationProgress = 0;
                lastMoveTime = currentTime;
            } else {
                animationProgress = deltaTime / gameSpeed;
            }

            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    changeDirection(0, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    changeDirection(0, 1);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    changeDirection(-1, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    changeDirection(1, 0);
                    break;
                case ' ':
                case 'Enter':
                    e.preventDefault();
                    if (!gameStarted) {
                        startGame();
                    }
                    break;
            }
        });

        // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ (Ø§Ù„Ø¥ÙŠÙ…Ø§Ø¡Ø§Øª)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
            handleSwipe();
        }, { passive: false });

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);

            // ØªØ­Ø¯ÙŠØ¯ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© Ø³Ø­Ø¨ ØµØ­ÙŠØ­
            if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) {
                return; // Ø§Ù„Ø³Ø­Ø¨ Ù‚ØµÙŠØ± Ø¬Ø¯Ø§Ù‹
            }

            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø£ÙƒØ¨Ø± Ø­Ø±ÙƒØ©
            if (absDeltaX > absDeltaY) {
                // Ø³Ø­Ø¨ Ø£ÙÙ‚ÙŠ
                if (deltaX > 0) {
                    // Ø³Ø­Ø¨ Ù„Ù„ÙŠÙ…ÙŠÙ†
                    changeDirection(1, 0);
                } else {
                    // Ø³Ø­Ø¨ Ù„Ù„ÙŠØ³Ø§Ø±
                    changeDirection(-1, 0);
                }
            } else {
                // Ø³Ø­Ø¨ Ø±Ø£Ø³ÙŠ
                if (deltaY > 0) {
                    // Ø³Ø­Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
                    changeDirection(0, 1);
                } else {
                    // Ø³Ø­Ø¨ Ù„Ù„Ø£Ø¹Ù„Ù‰
                    changeDirection(0, -1);
                }
            }
        }

        // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…Ø§ÙˆØ³ (Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±)
        let mouseStartX = 0;
        let mouseStartY = 0;
        let isMouseDown = false;

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            mouseStartX = e.clientX;
            mouseStartY = e.clientY;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isMouseDown) return;
            isMouseDown = false;
            
            touchEndX = e.clientX;
            touchEndY = e.clientY;
            touchStartX = mouseStartX;
            touchStartY = mouseStartY;
            handleSwipe();
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', restartGame);

        // Ø²Ø± ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø§ÙƒÙ†/Ø§Ù„ÙØ§ØªØ­
        const themeToggle = document.getElementById('themeToggle');
        themeToggle.addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
            
            if (isDarkMode) {
                currentColors = darkColors;
                themeToggle.textContent = 'â˜€ï¸';
            } else {
                currentColors = colors;
                themeToggle.textContent = 'ğŸŒ™';
            }
            
            // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            snakeColors = snake.map((_, i) => getSnakeColor(i));
            drawGame();
        });

        // Ø±Ø³Ù… Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
        initGame();
        drawGame();

        // Ù…Ù†Ø¹ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³ÙŠØ§Ù‚ÙŠØ©
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
